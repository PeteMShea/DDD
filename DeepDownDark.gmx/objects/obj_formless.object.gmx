<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_formless</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialise

image_speed = 0;

randomextraworm = 0.5;     //chance of spawning a random extra worm higher up

starty = y;
startx = x;

madnessfirstsight = 40;
seen = false;

//bobbing
targetx = x;
targety = y;
vx = 0;
vy = 0;
targetangle = image_angle;
startangle = image_angle;
boby = 45;      //amount of vertical bob
bobx = 30;       //amount of horizontal bob
bobangle = 15;  //amount of angular bob
maxtiltxtime = 60;
maxtiltytime = 60;
maxtiltangletime = 120;
xdir = 1;
ydir = -1;
angledir = 1;
tiltxtime = maxtiltxtime;
tiltytime = maxtiltytime;
tiltangletime = maxtiltangletime;

clampy = 430;       //how far up from initial rest point formless can travel- defines height of corridor

maxspeed = 0.5;
currentspeed = 0.01;            //begin with a tiny amount of speed as we detect zero speed as slowed to a stop at launch
acceleration = 0.0025;
deceleration = 0.0015;
turnspeed = 0.05;
decelerating = false;
hovery = 0;         //this is used to move the formless up and down separate from bobbing
firecounter = 300;      //frames between firing
snarltime = 300;    //how often snarl anim plays
idle = true;
shotinmouth = false;    //shot in ma mooth
shotcounter = 5;       //time in frames to flash red for
//shotcolour = make_colour_rgb(255, 88, 97);
shotcolour = make_colour_rgb(120, 0, 0);
currenthealth = 250;         //200
dying = false;
dead = false;
playerdead = false;


// spawning and launch vars
scale = 0.05;   //starting scale
scaleinc = 0.001;
scaleincaccleration = 0.0005;
scaledelay = 20;        //frames to wait before scaling begins
image_xscale = scale;
image_yscale = scale;
launchheight = y - 300;     //how far up ball launches at spawn time
launchcomplete = false;
launchmaxspeed = 5.0;
launchacceleration = 0.25;
launchdeceleration = 0.1;


instance_create(x, y, obj_fsoverlay);



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.pause == false
{
//-------------------------------------------------------------------------


if launchcomplete == false
    {
        // scaling
        scaledelay -= 1;
        if scaledelay &lt;= 0 &amp;&amp; scale &lt; 1.0
            {
                scale += scaleinc;
                scaleinc += scaleincaccleration;
                image_xscale = scale;
                image_yscale = scale;
            }
        
        //launch motion
        if y &gt; launchheight
            {
                if currentspeed &lt; launchmaxspeed currentspeed += launchacceleration        
            }
        
        if y &lt;= launchheight
            {
                if currentspeed &gt; 0 currentspeed -= launchdeceleration        
            }
                    
        y -= currentspeed;
        
        if currentspeed &lt;= 0        //slowed to a stop at top of launch
            {
                launchcomplete = true;

                instance_create(x, y, obj_fscollision);
                instance_create(x, y, obj_fsmouthcollision);

                timeline_index = tm_formlessidle;
                timeline_running = true;
                timeline_loop = true;
                starty = y;     //reset start position
            }
        //spawn worms
                    
        //calculate vars
        // box in which worms spawn- calculated in step time as formless may be moving
        spawnx1 = x - 68 * scale;
        spawny1 = y + 37 * scale;
        spawnx2 = x + 57 * scale;
        spawny2 = y + 72 * scale;
                            
        //now spawn a worm
        sx = irandom_range(spawnx1, spawnx2);
        sy = irandom_range(spawny1, spawny2);
        sangle = image_angle + 270;
        if scaledelay &gt;= 0 lifespan = 20 else lifespan += 1;            
        inst = instance_create(sx, sy, obj_fsworm);
        with(inst)
            {
                image_angle = other.sangle;
                depth = -10;
                lifespan = other.lifespan;
                fanangle = 0;           
            }                            
    }

if launchcomplete == true
    {
    
        //test for first seen by player and apply madness
        if global.formlessseen == false
                {
                    global.madness += madnessfirstsight;
                    global.formlessseen = true;    
                }
        
        // still alive
        if dead == false
        {       
                    
            //in range- temp
            if distance_to_object(obj_player) &lt; 600 &amp;&amp; seen == false
            {
                seen = true;
            }
            
            if seen == true &amp;&amp; dying == false &amp;&amp; playerdead == false
            {
                firecounter -= 1;
                
                if firecounter &lt;= 0
                {
                    firecounter = random_range(275, 325);
                    timeline_index = tm_formlessfire;
                    timeline_running = true;
                    timeline_position = 0;
                    timeline_loop = true;
                    idle = false;    
                }
            }
            
            if idle == true &amp;&amp; dying == false &amp;&amp; playerdead == false
            {
                snarltime -= 1;
                if snarltime &lt;= 0
                    {
                        snarltime = random_range(300, 400);
                        timeline_index = tm_formlesssnarl;
                        timeline_running = true;
                        timeline_loop = true;  
                    }
            }
            
            //bobbing motion
            
            tiltxtime -= 1;
            tiltytime -= 1;
            tiltangletime -= 1;
            
            if tiltxtime &lt;= 0  &amp;&amp; decelerating == false
                {
                    tiltxtime = maxtiltxtime + random_range(-15, 15);
                    if x &lt; startx - 100 xdir = 1;      //always go right if too far left
                    if x &gt; startx + 100 xdir = -1;        
                    targetx = x + (random_range(bobx, bobx + 10) * xdir);
                    xdir = round(random_range(-1, 1));     //go in random dir next time
                    //currentspeed = 0    
                }
            if tiltytime &lt;= 0 &amp;&amp; hovery == 0 &amp;&amp; decelerating == false
                {
                    tiltytime = maxtiltytime + random_range(-15, 15);
                    if y &lt; starty - 100 ydir = 1;      //always go up if lower than start zone
                    if y &gt; starty + 100 ydir = -1;
                    targety = y + (random_range(boby, boby + 15) * ydir);
                    ydir *= -1;     //go in opposite dir next time 
                    //currentspeed = 0   
                }
            if tiltangletime &lt;= 0
                {
                    tiltangletime = maxtiltangletime + random_range(-15, 15);
                    targetangle = image_angle + (random_range(bobangle/2, bobangle) * angledir);
                    angledir *= -1;     //go in opposite dir next time    
                }
            
            //movement
            destx = targetx;
            desty = targety + hovery;       //hovery is set by the timeline
            
            desty = clamp(desty, starty - clampy, starty + 120);
            
            if targetx != x || targety != y
                {        
                    vx = (destx - x);
                    vy = (desty - y);
                                
                    len = sqrt((vx * vx) + (vy * vy));
                                
                    vx = vx / len;
                    vy = vy / len;
                }
            if abs(x - destx) &lt; 5 &amp;&amp; abs(y - desty) &lt; 5 decelerating = true
            if abs(y - desty) &lt;= 1 hovery = 0;    
            
            if currentspeed &lt;= 0
                {
                    currentspeed = 0;
                    decelerating = false
                }
            if currentspeed &lt; maxspeed &amp;&amp; decelerating == false currentspeed += acceleration
            if decelerating == true 
                {
                    currentspeed -= deceleration    
                }
            
            x += vx * currentspeed
            y += vy * currentspeed
                
                
            //rotation
            angdif = angle_difference(image_angle, targetangle);
            if angdif &lt; -1
                {
                    image_angle += turnspeed 
                }
            if angdif &gt; -1
                {
                    image_angle -= turnspeed 
                }    
            
            
            
            //spawn worms
                    
                    //calculate vars
                    // box in which worms spawn- calculated in step time as formless may be moving
                    spawnx1 = x - 68;
                    spawny1 = y + 37;
                    spawnx2 = x + 57;
                    spawny2 = y + 72;
                            
                    //now spawn a worm
                    sx = irandom_range(spawnx1, spawnx2);
                    sy = irandom_range(spawny1, spawny2);
                    sangle = image_angle + 270;
                    
                    inst = instance_create(sx, sy, obj_fsworm);
                    with(inst)
                        {
                            image_angle = other.sangle;            
                        }
                
            if random(1) &lt; randomextraworm
            {
                    //now spawn an occasional extra worm outside main zone on top half of head
                    sx = irandom_range(spawnx1 - 20, spawnx2 + 20);
                    sy = irandom_range(spawny1 - 100, spawny1 - 30);
                    sangle = image_angle + 270;;
                    
                    inst = instance_create(sx, sy, obj_fsworm);
                    with(inst)
                        {
                            image_angle = other.sangle;
                            swerveangle = 1;
                        
                        }
            }
            
            // flash red when hit
            if shotinmouth == false &amp;&amp; shotcounter &lt;= 0
                {
                    image_blend = c_white;
                    if instance_exists(obj_fsoverlay) obj_fsoverlay.image_blend = c_white;
                }
            if shotinmouth == true
                {
                    image_blend = shotcolour;
                    if instance_exists(obj_fsoverlay) obj_fsoverlay.image_blend = shotcolour;
                    shotcounter = 3;
                    shotinmouth = false;
                }
            shotcounter -= 1;
        
        }
        
        //death
        if currenthealth &lt;= 0 &amp;&amp; dying == false
        {
                show_debug_message("formless dying");
                dying = true;
                timeline_index = tm_formlessdeath;
                timeline_position = 0;
                timeline_running = true;
                timeline_loop = false;
        }
        
        //player death
        if global.playerHealth &lt;= 0 &amp;&amp; playerdead == false
        {
             playerdead = true;
             timeline_index = tm_formlesslaugh;
             timeline_running = true;
             timeline_loop = true;
             targetangle = image_angle + 45;        
        
        }
    
    }

//------------------------------------------------
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
