<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spore</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialise

awake = false;
homing = false;
attack = false;

currenthealth = 1;     //HP
lifespanmax = random_range(1200,1500);   //how long spores live for once they have launched
lifespan = 0;
bouncecount = 10;   //maximum number of bounces before self destruct

awaketestmax = 60;     //how many frames between each time limpet checks to see if it should wake up
awaketest = 60;
awakerange = random_range(350, 450);   //distance from player before awakening
launchtimemax = 150;    //how many frames enemy will launch for before it begins homing
launchtime = 0;
takeoffspeed = 0.12;     //animation speed for take-off sequence 0.2
speedmax = 0.6;      //max speed of travel
speedmult = 0;
acceleration = 0.003;     //acceleratation
normalturnspeed = 4;      //number of degrees to turn per frame  4
maxturnspeed = 8;      //fast turn  8
turnspeed = normalturnspeed;
attackrange = 8;    //distance from player to switch to attack
homedirectrange = 64// distance from player to switch to direct homing
damage = 5;    //damage inflicted on player on self destruct
damageproximity = 8     //how close to player it destructs


homingtestmax = 120;     //how many frames between each time enemy checks LOS to target and adjusts aim  30
homingtest = 0;
linedistance = 64;     //how long a LOS ray test to perform when pathfinding- shorter equals quicker
aimoffset = 15;     //max number of degrees for random offset when pathfinding to target
avoidtest = 0;
if random(1) &lt;0.5 angleadjust = -60 else angleadjust = +60      //decide whether this gaunt avoids this number of degrees to the left or the right
collision = false;

aimx = x;
aimy = y;

start_angle = image_angle;
image_speed = 0;        //start in first frame of take-off animation
frame = 0;
hitanim = 0;
hitanimmax = 40;    //number of frames to play hitanim for
hitanimimagespeed = 0.25;   //anim speed for hit anim

damagecounter = 0;
explosionproximity = 80;       //how close to an explosion kills gaunt
shadow = false;








</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.pause == false 
{


//------------------------------------------

if awake == false &amp;&amp; awaketest &gt; 0
    {
    awaketest -= 1;
    
    }
if awake == false &amp;&amp; awaketest &lt;= 0
    {
        awaketest = awaketestmax;
        playerdist = distance_to_object(obj_player);
        if playerdist &lt;= awakerange
            {
                awake = true;
                aimx = x;
                aimy = y;
                aimangle = image_angle;
            } 
               
    }

if awake == true
{    

    
    // when we first wake up  set a point to travel to             
    if homing == false &amp;&amp; launchtime == 0
        {

            aimx = x + lengthdir_x(200, image_angle);
            aimy = y + lengthdir_y(200, image_angle);
            aimangle = point_direction(x, y, aimx, aimy);             

        }
    
    // and now start  the takeoff
    if  homing == false &amp;&amp; launchtime &lt; launchtimemax
        {
            launchtime +=1
            if launchtime &gt;= launchtimemax/2 &amp;&amp; shadow == false
            {            
                image_index = 1;   //scale up as it launches
                // create a shadow object to follow this one
                instance_create(x,y, obj_sporeshadow);
                shadow = true;
            }
        }
    
    if  homing == false &amp;&amp; launchtime &gt;= launchtimemax
        {
            homing = true;
            image_index = 2;        //spines out
            image_speed = 0;
            aimx = obj_player.x + offsetx;
            aimy = obj_player.y + offsety;            
            aimangle = point_direction(x, y, aimx, aimy); 
        }
    
    if homing == true 
    {
        lifespan +=1
        if lifespan &gt;= lifespanmax currenthealth = 0;
        //leader = instance_nearest(x, y, obj_spawnleader);
        playerdist = distance_to_point(obj_player.x, obj_player.y);
        if playerdist &lt;= attackrange attack = true else attack = false

        aimx = obj_player.x + offsetx;
        aimy = obj_player.y + offsety;
       
                
        //perform LOS check ever Z frames
        if homingtest &lt; homingtestmax homingtest +=1    
        if homingtest &gt;= homingtestmax 
        {
            // first LOS check dead ahead
            linestartx = x;
            linestarty = y;

            aimangle = point_direction(x,y, aimx, aimy);
            lineendx = x + lengthdir_x(linedistance, aimangle);
            lineendy = y + lengthdir_y(linedistance, aimangle);
            hit = 0;
            debug = false;
            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
            //show_debug_message("hit: " + string(hit));
            if hit != 0
                {
                    lineangle = point_direction(linestartx, linestarty, lineendx, lineendy);
                    // left first
                    aimangle +=45                                     
                    lineendx = linestartx + lengthdir_x(linedistance, aimangle);
                    lineendy = linestarty + lengthdir_y(linedistance, aimangle);
                    //show_debug_message("Testing Left");
                    debug = false
                    hit = 0   
                    LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                    if hit != 0
                        {
                        //right 
                            lefthit = hit;
                            aimangle -=90
                            lineendx = linestartx + lengthdir_x(linedistance, aimangle);
                            lineendy = linestarty + lengthdir_y(linedistance, aimangle);
                            //show_debug_message("Testing Right");
                            debug = false
                            hit = 0   
                            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                   
    
                            if hit !=0      //next try left + 90 degrees
                                {    
                                    aimangle = +135;
                                    lineendx = x + lengthdir_x(linedistance, aimangle);
                                    lineendy = y + lengthdir_y(linedistance, aimangle);
                                    debug = false
                                    hit = 0   
                                    LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);  
                                    //show_debug_message("Left and Right blocked, aimx aimy:" + string(aimx) + " , " + string(aimy) + " , endxy endy" + string(lineendx) + ", " + string(lineendy));
                                    
                                    if hit !=0      //finally try right + 90 degrees
                                        {    
                                            aimangle = -180;
                                            lineendx = x + lengthdir_x(linedistance, aimangle);
                                            lineendy = y + lengthdir_y(linedistance, aimangle);
                                            debug = false;
                                            hit = 0   
                                            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                                            
                                            if hit !=0  //if still no free way to go- aim backwards
                                                {
                                                    lineendx = x + lengthdir_x(linedistance, image_angle - 180);
                                                    lineendy = y + lengthdir_y(linedistance, image_angle - 180);
                                                }
                                                                                      
                                        }    
                                    
                                }       
                                    
                                    
                                
                        }
                }
        
        
            homingtest = 0;             
        }

     } 

     //check nothing directly in front of gaunt
     //aimangle = point_direction(x, y, aimx, aimy);   

/*    
     if avoidtest &lt;=0
     {
         avoid = noone;
         avoid = collision_point(x + lengthdir_x(16, image_angle), y + lengthdir_y(16, image_angle), obj_spawn, false, true);
         if avoid == noone avoid = collision_point(x + lengthdir_x(64, image_angle), y + lengthdir_y(64, image_angle), obj_asteroid, false, true);
         //if avoid == noone avoid = collision_point(x + lengthdir_x(52, image_angle), y + lengthdir_y(52, image_angle), obj_gaunt, false, true);
        
         if avoid != noone      //if something directly in front swerve away
             {
                //instance_create(x + lengthdir_x(64, image_angle), y + lengthdir_y(64, image_angle),debug_spot);
                avoidtest = 60;
                aimangle = image_angle + angleadjust;
                speedmult = speedmult * 0.8;
                turnspeed = maxturnspeed;
                //instance_create(x + lengthdir_x(52, aimangle), y + lengthdir_y(52, aimangle),obj_debug);         
             }         
     }
     if avoidtest &gt; 0 
         {
            avoidtest -= 1;
         }
     else turnspeed = normalturnspeed;

*/    
          
     //now turn towards aim point    
    anglediff = angle_difference(image_angle, aimangle);

    if homing == true image_angle -= sign(anglediff) * turnspeed;
    
    //now move along facing direction if no spawn in the way
        
    movex = x + lengthdir_x(16, image_angle); 
    movey = y + lengthdir_y(16, image_angle);
    
             
        vx = (movex - x);
        vy = (movey - y);
                    
        len = sqrt(vx * vx + vy * vy);
                            
        vx = vx / len;
        vy = vy / len;
                
    
        if speedmult &lt;= speedmax speedmult += acceleration
        
    
    coltest = collision_point(x+vx * speedmult, y+vy * speedmult, obj_block, true, true);
    if coltest == noone coltest = collision_point(x+vx * speedmult, y+vy * speedmult, obj_asteroid, true, true) 
    
    if coltest == noone &amp;&amp; awake == true  
        { 
                         
            x += vx * speedmult
            y += vy * speedmult
    
        }
    else
        {
            image_angle += 180;
            image_index = 1;
            homing = false;
            lifespan = 0;
            launchtime = launchtimemax * 0.9;
            bouncecount -=1;          
        
        }

if distance_to_point(obj_player.x, obj_player.y) &lt;= damageproximity
    {
    // blow up and destroy and damage player
    
    effect_create_above(ef_explosion, x, y, 0, c_lime);
    bx = x;
    by = y;
    script_execute(scr_sporeburst, bx, by);
    global.playerHealth -= damage;
    global.playerdamaged = 20;
    loc_x = x;
    loc_y = y;
    script_execute(scr_shipvisualdamage, x, y, loc_x, loc_y, damage); 
    instance_destroy();
    }        
        
                      
}

if bouncecount &lt;= 0 currenthealth = 0

if currenthealth &lt;=0 
    {
        bx = x;
        by = y;
        script_execute(scr_sporeburst, bx, by);                          
        instance_destroy();
    }
    
    
// if near an explosion reduce health to death
if instance_exists(obj_explosion128)
    {
        proximity = distance_to_object(obj_explosion128)
        if proximity &lt;= explosionproximity currenthealth = 0;
    }

    
//----------------------------------------
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_hugeblock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// clean up if stuck in environment

instance_destroy();


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
