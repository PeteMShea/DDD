<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_asteroid</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialise
deceleration = 3;
terminalvelocity = 0.5;
rotdecay = 0.95;        //0.99
minrotation = 0.5;
massmult = 0.5;     //how much of player speed is transferred to asteroid on collision
damagemult = 50;     //how much player speed is transferred into damage amount on collision
asteroidhealth = irandom_range(30,60); 
gold = 0;
nugget = false;
wreck = false;
blackbox = false;
counter = 120;

image_speed = 0;
asteroidimage = irandom_range(0,4);
image_index = asteroidimage;
image_angle = irandom(360);

speed_x = 0;
speed_y = 0;
rotspeed = 0;
hitcounter = 0;
asteroidhit = 0;
hit_x = 0;
hit_y = 0;
h_angle = 0;
hitspeed_x = 0;
hitspeed_y = 0;


lit = false;

if lit == true
{

/////////////////////////////////////////////////////////////////////////////
// Lighting Setup
//This script goes on the 'create' event of objects that need Sprite Lamp's
//lighting effects.
//The uniform variable stuff shouldn't really change, but down the bottom are
//the bits where you set your desired values for stuff.


/********************************************************************************/
//A whole bunch of shader variables - the 'u_' prefix means 'uniform variable'.
//These are just hooks to communicate with the shader.

//Maps. Note that we don't have to do the diffuse map - that's included as the
//base texture (gm_BaseTexture) automatically.
u_NormalDepthMap = shader_get_sampler_index(SpriteLampShader, "sl_NormalDepthMap");
u_SpecGlossMap = shader_get_sampler_index(SpriteLampShader, "sl_SpecGlossMap");
u_AOMap = shader_get_sampler_index(SpriteLampShader, "sl_AOMap");
u_EmissiveMap = shader_get_sampler_index(SpriteLampShader, "sl_EmissiveMap");

//Sprite Lamp variables that are handled by scripts
u_LightPos = shader_get_uniform(SpriteLampShader, "sl_LightPos");
u_SpriteAngle = shader_get_uniform(SpriteLampShader, "sl_SpriteAngle");
u_TextureRes = shader_get_uniform(SpriteLampShader, "sl_TextureRes");
u_LightColour = shader_get_uniform(SpriteLampShader, "sl_LightColour");

//Sprite Lamp variables that are set by the user
u_CelLevel = shader_get_uniform(SpriteLampShader, "sl_CelLevel");
u_Shininess = shader_get_uniform(SpriteLampShader, "sl_Shininess");
u_WrapAroundLevel = shader_get_uniform(SpriteLampShader, "sl_WrapAroundLevel");
u_AOStrength = shader_get_uniform(SpriteLampShader, "sl_AOStrength");
u_EmissiveStrength = shader_get_uniform(SpriteLampShader, "sl_EmissiveStrength");
u_AmplifyDepth = shader_get_uniform(SpriteLampShader, "sl_AmplifyDepth");

u_UpperAmbientColour = shader_get_uniform(SpriteLampShader, "sl_UpperAmbientColour");
u_LowerAmbientColour = shader_get_uniform(SpriteLampShader, "sl_LowerAmbientColour");
/********************************************************************************/



/********************************************************************************/
//Set your different maps here! Note that your diffuse map isn't done this way - 
//diffuse comes from whatever image is assigned to the object in the usual fashion.
normalDepthTexture = sprite_get_texture(spr_asteroidnormal, asteroidimage);
//specGlossMap = sprite_get_texture(spr_shipSharkNormal, asteroidimage);
specGlossMap = sprite_get_texture(spr_asteroid, asteroidimage);
aoMap = sprite_get_texture(spr_asteroid, asteroidimage);
emissiveMap = sprite_get_texture(spr_asteroid, asteroidimage);
//(note - this example doesn't have an emissive map so I'm using the diffuse map as
//a dummy and turning the emissive strength variable to zero. Eventually I'll have
//a couple of versions of the shader, so if you're not using certain features you
//done have to screw around with this kind of thing)


//Set shader variables here. Note that they get sent every frame,
//so feel free to change these values in script during play.
celLevel = 0.0;     //0
shininess = 50.0;   //50
wrapAroundLevel = 0.0;
aoStrength = 0.4;       //0.3
emissiveStrength = 0.00;     //0
amplifyDepth = 1.5;     //0.5

//Set texture resolution - needed for self-shadows. Presumably there is some way
//to automate this process - if you know how, tell me!
textureWidth = 512;
textureHeight = 256;


//Ambient colour components.
upperAmbient_Red = 0.2;     //0.1
upperAmbient_Green = 0.2;
upperAmbient_Blue = 0.2;

lowerAmbient_Red = 0.01;     //0.03
lowerAmbient_Green = 0.01;
lowerAmbient_Blue = 0.01;


//The nearest lightsource.
lightSource = instance_nearest(x,y,oLightSourceAsteroid);
}

//add the light to follow player



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// rotation
image_angle += rotspeed * 60 * delta_time /1000000

if abs(rotspeed) &gt;= minrotation
    {
        rotspeed *= rotdecay;
    }
    
// movement
x += speed_x * 60 * delta_time /1000000;
y += speed_y * 60 * delta_time /1000000;

// reduce speed by deceleration amount each frame unless at min speed
if abs(speed_x) &gt; terminalvelocity
    {
        speed_x -= (speed_x * deceleration/1000);
    }
if abs(speed_y) &gt; terminalvelocity
    {
        speed_y -= (speed_y * deceleration/1000);
    }

if hitcounter &gt;= 0 hitcounter -= 1;


//check for magnet extraction

if gold &gt; 0 &amp;&amp; obj_player.magnetextract != 0
{
    counter -= 1
    if counter * 60 * delta_time /1000000 &lt;= 0
        {
            counter = 120;
            playerdist = distance_to_object(obj_player);
            if playerdist &lt;= obj_player.magnetextract
                {
                    asteroidhealth = 0;                
                }        
        }
}


if asteroidhit != 0
{
    // collided with player or bullet- damage and push away
    
    //global.playerHealth -= obj_player.speed * damagemult + 1;
    //global.playerdamaged = 20;
    //show_debug_message("Hit!");
    //instance_create(hit_x, hit_y, obj_debug);
    

    
    if hitcounter * 60 * delta_time /1000000 &lt;= 0
    {
        vx = (hit_x - x);
        vy = (hit_y - y);
            
        if vx != 0 || vy != 0 len = sqrt(vx * vx + vy * vy) else len = 0;
         
        if len != 0
        {   
        vx = vx / len;
        vy = vy / len;
        }
        
        if hitspeed_x != 0 || hitspeed_y != 0 speedlen = sqrt(hitspeed_x * hitspeed_x + hitspeed_y * hitspeed_y) else speedlen = 0; 
        
        speedmult = abs(speedlen) * massmult;
        
        //bounce first - inverting any asteroid motion if hit by player
        if asteroidhit == 1
        {
            speed_x = -speed_x * 0.8;
            speed_y = -speed_y * 0.8;
        }
        
        //now do rotational force impact
            t_angle = point_direction(x, y, ext_x, ext_y);
            h_angle = point_direction(x, y, hit_x, hit_y);
            var facingMinusTarget = h_angle - t_angle;
            var angleDiff = facingMinusTarget;

            if(abs(facingMinusTarget) &gt; 180)
            {
                if(h_angle &gt; t_angle)
                {
                    angleDiff = -1 * ((360 - h_angle) + t_angle);
                }
                else
                {
                    angleDiff = (360 - t_angle) + h_angle;
                }
            }

            if(angleDiff &gt; 0)
                {
                    rotspeed -= 1;
                }
            else if(angleDiff &lt; 0)
                {
                    rotspeed += 1;
                }            

            //show_debug_message("h_angle: " + string(h_angle) + " , t_angle: " + string(t_angle));
        
        
        //now apply any force from the player collision
        speed_x -= vx * speedmult;
        speed_y -= vy * speedmult;
        
        if asteroidhit == 1         //hit by player
            {
                hitcounter = 30;
                asteroidhealth -= (abs(hitspeed_x) + abs(hitspeed_y)) * damagemult;
            }
        if asteroidhit == 2 asteroidhealth -= (abs(hitspeed_x) + abs(hitspeed_y)) * damagemult * obj_player.bulletdamage;        
        asteroidhit = 0;
    }
    
    

    //show_debug_message(string(asteroidhealth));
    
}
// death
if asteroidhealth &lt;=0
    {
        bx = x;
        by = y;
        if wreck == false
            {
                audio_sound_gain(snd_AsteroidBurst, 1.0, 0);
                audio_play_sound_at(snd_AsteroidBurst, x, y, 0, 600, 1200, 1, false, 100);                
                script_execute(scr_asteroidburst, bx, by, gold, nugget);
            }
        else if wreck == true
            {
                for(i = 0; i &lt; 9; i +=1)
                    {
                        bx = x + irandom_range(-8, 8);
                        by = y + irandom_range(-8, 8);
                        script_execute(scr_wreckdebrisvfx, bx, by);                
                    }
            
            }
        instance_destroy();
    }


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_block">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// hit anything else- push away

speed_x = -speed_x * 0.8;
speed_y = -speed_y * 0.8;

asteroidhealth -= (abs(speed_x) + abs(speed_y)) * damagemult;
//show_debug_message(string(health));

if asteroidhealth &lt;=0
{
        bx = x - 4;
        by = y - 4;
        script_execute(scr_asteroidburst, bx, by, gold);
        instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_asteroid">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if wreck == false
{
    // hit anything else- push away
    
    speed_x = -speed_x * 0.9;
    speed_y = -speed_y * 0.9;
    
    asteroidhealth -= (abs(speed_x) + abs(speed_y));
    //show_debug_message(string(health));
    
    if asteroidhealth &lt;=0
    {
            bx = x - 4;
            by = y - 4;
            script_execute(scr_asteroidburst, bx, by, gold);
            instance_destroy();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_goldasteroid">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// hit anything else- push away

speed_x = -speed_x;
speed_y = -speed_y;

asteroidhealth -= (abs(speed_x) + abs(speed_y));
//show_debug_message(string(health));

if asteroidhealth &lt;=0
{
        bx = x - 4;
        by = y - 4;
        script_execute(scr_asteroidburst, bx, by, gold);
        instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//lightSource = instance_nearest(x,y,oLightSourceAsteroid);

if lit == true
{
if instance_exists(lightSource)
{
    shader_set(SpriteLampShader);
    
    shader_set_uniform_f(u_SpriteAngle, image_angle * pi / 180.0);
    shader_set_uniform_f(u_TextureRes, textureWidth, textureHeight);
    shader_set_uniform_f(u_LightPos,
            lightSource.cameraSpacePosX, lightSource.cameraSpacePosY,
            lightSource.zPosition);
    shader_set_uniform_f(u_LightColour,
            lightSource.colourRed, lightSource.colourGreen, lightSource.colourBlue);
             
             
    texture_set_stage(u_NormalDepthMap, normalDepthTexture);
    texture_set_stage(u_SpecGlossMap, specGlossMap);
    texture_set_stage(u_AOMap, aoMap);
    texture_set_stage(u_EmissiveMap, emissiveMap);
    
    shader_set_uniform_f(u_CelLevel, celLevel);
    shader_set_uniform_f(u_Shininess, shininess);
    shader_set_uniform_f(u_WrapAroundLevel, wrapAroundLevel);
    shader_set_uniform_f(u_AOStrength, aoStrength);
    shader_set_uniform_f(u_EmissiveStrength, emissiveStrength);
    shader_set_uniform_f(u_AmplifyDepth, amplifyDepth);
    
    shader_set_uniform_f(u_UpperAmbientColour, 
            upperAmbient_Red, upperAmbient_Green, upperAmbient_Blue);
    shader_set_uniform_f(u_LowerAmbientColour,
            lowerAmbient_Red, lowerAmbient_Green, lowerAmbient_Blue);

}
}
draw_self();

shader_reset();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
