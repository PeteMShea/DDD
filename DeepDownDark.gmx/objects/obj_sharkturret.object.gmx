<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_SharkTurret</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// initialise

joyleftx = 0;
joylefty = 0;
joystickused =0;
shoot_counter = 0;



// move the turret to start
x = obj_player.x + lengthdir_x(18, obj_player.image_angle);
y = obj_player.y + lengthdir_y(18, obj_player.image_angle);
image_angle = 270;
image_speed = 0;

desired_angle = image_angle;



/////////////////////////////////////////////////////////////////////////////
// Lighting Setup
//This script goes on the 'create' event of objects that need Sprite Lamp's
//lighting effects.
//The uniform variable stuff shouldn't really change, but down the bottom are
//the bits where you set your desired values for stuff.


/********************************************************************************/
//A whole bunch of shader variables - the 'u_' prefix means 'uniform variable'.
//These are just hooks to communicate with the shader.

//Maps. Note that we don't have to do the diffuse map - that's included as the
//base texture (gm_BaseTexture) automatically.
u_NormalDepthMap = shader_get_sampler_index(SpriteLampShader, "sl_NormalDepthMap");
u_SpecGlossMap = shader_get_sampler_index(SpriteLampShader, "sl_SpecGlossMap");
u_AOMap = shader_get_sampler_index(SpriteLampShader, "sl_AOMap");
u_EmissiveMap = shader_get_sampler_index(SpriteLampShader, "sl_EmissiveMap");

//Sprite Lamp variables that are handled by scripts
u_LightPos = shader_get_uniform(SpriteLampShader, "sl_LightPos");
u_SpriteAngle = shader_get_uniform(SpriteLampShader, "sl_SpriteAngle");
u_TextureRes = shader_get_uniform(SpriteLampShader, "sl_TextureRes");
u_LightColour = shader_get_uniform(SpriteLampShader, "sl_LightColour");

//Sprite Lamp variables that are set by the user
u_CelLevel = shader_get_uniform(SpriteLampShader, "sl_CelLevel");
u_Shininess = shader_get_uniform(SpriteLampShader, "sl_Shininess");
u_WrapAroundLevel = shader_get_uniform(SpriteLampShader, "sl_WrapAroundLevel");
u_AOStrength = shader_get_uniform(SpriteLampShader, "sl_AOStrength");
u_EmissiveStrength = shader_get_uniform(SpriteLampShader, "sl_EmissiveStrength");
u_AmplifyDepth = shader_get_uniform(SpriteLampShader, "sl_AmplifyDepth");

u_UpperAmbientColour = shader_get_uniform(SpriteLampShader, "sl_UpperAmbientColour");
u_LowerAmbientColour = shader_get_uniform(SpriteLampShader, "sl_LowerAmbientColour");
/********************************************************************************/



/********************************************************************************/
//Set your different maps here! Note that your diffuse map isn't done this way - 
//diffuse comes from whatever image is assigned to the object in the usual fashion.
normalDepthTexture = sprite_get_texture(spr_SharkTurretNormal, 0);
//specGlossMap = sprite_get_texture(spr_shipSharkNormal, 0);
specGlossMap = sprite_get_texture(spr_SharkTurretGS, 0);
aoMap = sprite_get_texture(spr_SharkTurret, 0);
emissiveMap = sprite_get_texture(spr_SharkTurret, 0);
//(note - this example doesn't have an emissive map so I'm using the diffuse map as
//a dummy and turning the emissive strength variable to zero. Eventually I'll have
//a couple of versions of the shader, so if you're not using certain features you
//done have to screw around with this kind of thing)


//Set shader variables here. Note that they get sent every frame,
//so feel free to change these values in script during play.
celLevel = 0.0;     //0
shininess = 100.0;   //40
wrapAroundLevel = 0.0;
aoStrength = 0.4;       //0.4
emissiveStrength = 0.00;     //0
amplifyDepth = 1.5;     //1.5

//Set texture resolution - needed for self-shadows. Presumably there is some way
//to automate this process - if you know how, tell me!
textureWidth = 512;
textureHeight = 256;


//Ambient colour components.
upperAmbient_Red = 0.2;     //0.2
upperAmbient_Green = 0.2;
upperAmbient_Blue = 0.2;

lowerAmbient_Red = 0.05;     //0.05
lowerAmbient_Green = 0.05;
lowerAmbient_Blue = 0.05;


//The nearest lightsource.
instance_create(x+16, y-16, oLightSourceTurret);
lightSource = instance_nearest(x,y,oLightSourceTurret);

//add the light to follow player



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// move the gun with the ship and have it rotate independently


joyleftx = gamepad_axis_value(0, gp_axisrh);
joylefty = gamepad_axis_value(0, gp_axisrv);


// Rotation- joystick
    if joyleftx != 0 || joylefty != 0
    {
        jjx = -joyleftx
        jjy = -joylefty
        image_angle = point_direction(0, 0, jjx, jjy);
        joystickused = 1;
    }
       
// Rotation Mouse (left stick not used)
    if joystickused != 1
    {
        desired_angle = point_direction(x, y, mouse_x, mouse_y);
    }

// turn the turret towards the desired angle
if abs(desired_angle - image_angle) &gt; 2
    {
     
        if angle_difference(desired_angle, image_angle) &lt; -2 image_angle -= 2;
        if obj_player.turretturn &gt;= 2 &amp;&amp; angle_difference(desired_angle, image_angle) &lt; -2 image_angle -= 2;    // turret turns twice in a frame if turnspeed higher
        if obj_player.turretturn &gt;= 3 &amp;&amp; angle_difference(desired_angle, image_angle) &lt; -2 image_angle -= 2;      //three times                  
        if angle_difference(desired_angle, image_angle) &gt; 2 image_angle += 2;
        if obj_player.turretturn &gt;= 2 &amp;&amp; angle_difference(desired_angle, image_angle) &gt; 2 image_angle += 2;        
        if obj_player.turretturn &gt;= 3 &amp;&amp; angle_difference(desired_angle, image_angle) &gt; 2 image_angle += 2;                    
    }
        

// clean up
if obj_player.turret == false instance_destroy();


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

shader_set(SpriteLampShader);

shader_set_uniform_f(u_SpriteAngle, image_angle * pi / 180.0);
shader_set_uniform_f(u_TextureRes, textureWidth, textureHeight);
shader_set_uniform_f(u_LightPos,
        lightSource.cameraSpacePosX, lightSource.cameraSpacePosY,
        lightSource.zPosition);
shader_set_uniform_f(u_LightColour,
        lightSource.colourRed, lightSource.colourGreen, lightSource.colourBlue);
         
         
texture_set_stage(u_NormalDepthMap, normalDepthTexture);
texture_set_stage(u_SpecGlossMap, specGlossMap);
texture_set_stage(u_AOMap, aoMap);
texture_set_stage(u_EmissiveMap, emissiveMap);

shader_set_uniform_f(u_CelLevel, celLevel);
shader_set_uniform_f(u_Shininess, shininess);
shader_set_uniform_f(u_WrapAroundLevel, wrapAroundLevel);
shader_set_uniform_f(u_AOStrength, aoStrength);
shader_set_uniform_f(u_EmissiveStrength, emissiveStrength);
shader_set_uniform_f(u_AmplifyDepth, amplifyDepth);

shader_set_uniform_f(u_UpperAmbientColour, 
        upperAmbient_Red, upperAmbient_Green, upperAmbient_Blue);
shader_set_uniform_f(u_LowerAmbientColour,
        lowerAmbient_Red, lowerAmbient_Green, lowerAmbient_Blue);


draw_self();

shader_reset();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
