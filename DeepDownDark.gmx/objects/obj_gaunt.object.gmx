<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_gaunt_takeoff</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-50</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialise

awake = false;
homing = false;
attack = false;

currenthealth = 10;     //HP 

awaketestmax = 60;     //how many frames between each time limpet checks to see if it should wake up
awaketest = 60;
awakerange = random_range(250 * global.RM, 400 * global.RM);   //distance from player before awakening
launchtimemax = 120;    //how many frames gaunt will launch for before it begins homing
launchtime = -60;
takeoffspeed = 0.12;     //animation speed for take-off sequence 0.2
speedmax = 1.2;      //max speed of travel
speedmult = 0;
acceleration = 0.005;     //acceleratation
normalturnspeed = 2;      //number of degrees to turn per frame
maxturnspeed = 4;      //fast turn
turnspeed = normalturnspeed;
attackrange = 8 * global.RM;    //distance from player to switch to attack animations
homedirectrange = 64 * global.RM// distance from player to switch to direct homing
gauntdamage = 5;    //damage inflicted on player every damagecountermax frames (see below)
damagecountermax = 60;  //how often gaunt can damage- i.e. every x frames

maxanimspeed = 1.5;   //maximum flying animation speed- speedmult is subtracted from this to get anim speed- so faster flight means less wing strokes
attackanimspeed = 0.75      //attack animation speed

homingtestmax = 30;     //how many frames between each time limpet checks LOS to player and adjusts aim
homingtest = 0;
homingoffset = 16 * global.RM;  //maximum number of pixels offset from centre of ship when homing towards it
linedistance = 32 * global.RM;     //how long a LOS ray test to perform when pathfinding- shorter equals quicker
aimoffset = 15;     //max number of degrees for random offset when pathfinding to target
avoidtest = 0;
if random(1) &lt;0.5 angleadjust = -45 else angleadjust = +45      //decide whether this gaunt avoids this number of degrees to the left or the right

aimx = x;
aimy = y;

start_angle = image_angle;
image_speed = 0;        //start in first frame of take-off animation
frame = 0;
hitanim = 0;
hitanimmax = 40;    //number of frames to play hitanim for
hitanimimagespeed = 0.25;   //anim speed for hit anim

damagecounter = 0;
explosionproximity = 80 * global.RM;       //how close to an explosion kills enemies



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if global.pause == false 
{


//------------------------------------------

if awake == false &amp;&amp; awaketest &gt; 0
    {
    awaketest -= 1;
    
    }
if awake == false &amp;&amp; awaketest &lt;= 0
    {
        awaketest = awaketestmax;
        playerdist = distance_to_object(obj_player);
        if playerdist &lt;= awakerange
            {
                awake = true;
                aimx =x;
                aimy = y;
            }   
    }

if awake == true
{    
    
    // when we first wake up  set a point to travel to             
    if homing == false &amp;&amp; launchtime == 0
        {

            aimx = x + lengthdir_x(200, image_angle);
            aimy = y + lengthdir_y(200, image_angle);            

        }
    
    // and now start animating the takeoff- 12 frames total
    if  homing == false &amp;&amp; launchtime &lt; launchtimemax
        {
            launchtime +=1
            if frame != 99
            {
                frame = image_index;
                if frame &lt;11
                    {
                        image_speed = takeoffspeed;
                        //show_debug_message(string(frame));
                    }
                else
                    {
                        image_speed = 0;
                        frame = 99;
                    } 
            
            }
            launchtime +=1
            //show_debug_message("L: " + string(launchtime));
        }
    
    if  homing == false &amp;&amp; launchtime &gt;= launchtimemax
        {
            homing = true;
            sprite_index = spr_gaunt_flying;
            image_index = 0;
            image_speed = 0;
        }
    
    if homing == true 
    {
        playerdist = distance_to_point(obj_player.x, obj_player.y);
        if playerdist &lt;= attackrange attack = true else attack = false
        
        //perform LOS check ever Z frames
        if homingtest &lt; homingtestmax homingtest +=1    
        if homingtest &gt;= homingtestmax 
        {
            // first LOS check dead ahead +/- aimoffset degrees from player target for variety
            linestartx = x;
            linestarty = y;
            if playerdist &lt;= homedirectrange aimoffset = 0;
            aimangle = point_direction(x,y, obj_player.x, obj_player.y) + random_range(-aimoffset, aimoffset);
            lineendx = x + lengthdir_x(linedistance, aimangle);
            lineendy = y + lengthdir_y(linedistance, aimangle);
            hit = 0;
            debug = false;
            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
            //show_debug_message("hit: " + string(hit));
            if hit != 0
                {
                    lineangle = point_direction(linestartx, linestarty, lineendx, lineendy);
                    // left first
                    aimangle +=45
                    lineendx = linestartx + lengthdir_x(linedistance, aimangle);
                    lineendy = linestarty + lengthdir_y(linedistance, aimangle);
                    //show_debug_message("Testing Left");
                    debug = false
                    hit = 0   
                    LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                    if hit != 0
                        {
                        //right 
                            lefthit = hit;
                            aimangle -=90
                            lineendx = linestartx + lengthdir_x(linedistance, aimangle);
                            lineendy = linestarty + lengthdir_y(linedistance, aimangle);
                            //show_debug_message("Testing Right");
                            debug = false
                            hit = 0   
                            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                   
    
                            if hit !=0      //next try left + 90 degrees
                                {    
                                    aimangle = +135;
                                    lineendx = x + lengthdir_x(linedistance, aimangle);
                                    lineendy = y + lengthdir_y(linedistance, aimangle);
                                    debug = false
                                    hit = 0   
                                    LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);  
                                    //show_debug_message("Left and Right blocked, aimx aimy:" + string(aimx) + " , " + string(aimy) + " , endxy endy" + string(lineendx) + ", " + string(lineendy));
                                    
                                    if hit !=0      //finally try right + 90 degrees
                                        {    
                                            aimangle = -180;
                                            lineendx = x + lengthdir_x(linedistance, aimangle);
                                            lineendy = y + lengthdir_y(linedistance, aimangle);
                                            debug = false
                                            hit = 0   
                                            LOScheck(linestartx, linestarty, lineendx, lineendy, linedistance, hit, debug);
                                            
                                            if hit !=0  //if still no free way to go- aim backwards
                                                {
                                                    lineendx = x + lengthdir_x(linedistance, image_angle - 180);
                                                    lineendy = y + lengthdir_y(linedistance, image_angle - 180);
                                                }
                                                                                      
                                        }    
                                    
                                }       
                                    
                                    
                                
                        }
                }
            if avoidtest &lt;=0        //update aim point unless currently avoiding
                {
                    aimx = lineendx;
                    aimy = lineendy;
                }
            //instance_create(aimx, aimy, obj_debug);
            homingtest = 0;                  
        }
     } 

     //check nothing directly in front of gaunt
     aimangle = point_direction(x, y, aimx, aimy);   
     if avoidtest &lt;=0
     {
         avoid = noone;
         avoid = collision_point(x + lengthdir_x(64, image_angle), y + lengthdir_y(64, image_angle), obj_asteroid, false, true);
         //if avoid == noone avoid = collision_point(x + lengthdir_x(52, image_angle), y + lengthdir_y(52, image_angle), obj_gaunt, false, true);
        
         if avoid != noone      //if something directly in front swerve away
             {
                //instance_create(x + lengthdir_x(64, image_angle), y + lengthdir_y(64, image_angle),debug_spot);
                avoidtest = 60;
                aimangle = image_angle + angleadjust;
                speedmult = speedmult * 0.8;
                turnspeed = maxturnspeed;
                //instance_create(x + lengthdir_x(52, aimangle), y + lengthdir_y(52, aimangle),obj_debug);         
             }         
     }
     if avoidtest &gt; 0 
         {
            avoidtest -= 1;
         }
     else turnspeed = normalturnspeed;

     
          
     //now turn towards aim point    
    anglediff = angle_difference(image_angle, aimangle);

    if homing == true image_angle -= sign(anglediff) * turnspeed;
    
    //now move along facing direction
        
    movex = x + lengthdir_x(100 * global.RM, image_angle); 
    movey = y + lengthdir_y(100 * global.RM, image_angle); 
        
                
    vx = (movex - x);
    vy = (movey - y);
                
    len = sqrt(vx * vx + vy * vy);
                        
    vx = vx / len;
    vy = vy / len;
            

    if speedmult &lt;= speedmax speedmult += acceleration               
    x += vx * speedmult
    y += vy * speedmult
    
    if homing == true &amp;&amp; hitanim &lt;= 0 image_speed = maxanimspeed - speedmult;
    
    if hitanim &gt;0 &amp;&amp; attack == false
        {
            sprite_index = spr_gaunt_hit;
            image_speed = hitanimimagespeed;
            speedmult = speedmax * 0.5;           
            hitanim -= 1;
            if hitanim == 0 sprite_index = spr_gaunt_flying;
        }
        
    if hitanim == 0 &amp;&amp; attack == false &amp;&amp; homing == true
        {
            sprite_index = spr_gaunt_flying;
        }
        
    if attack == true &amp;&amp; damagecounter &lt;= 0
        {
            damagecounter = damagecountermax
            sprite_index = spr_gaunt_attack;
            image_speed = attackanimspeed;       
            speedmult = speedmax * 0.1;
            global.playerHealth -= gauntdamage;
            global.playerdamaged = 20;
            loc_x = x;
            loc_y = y;
            damage = gauntdamage;
            script_execute(scr_shipvisualdamage, x, y, loc_x, loc_y, damage);            
            script_execute(scr_smalldebris, loc_x, loc_y)         
        }
    if attack == true &amp;&amp; damagecounter &gt; 0
        {
            damagecounter -=1;
        }                        
    }

if currenthealth &lt;=0 
{
    debrisangle = image_angle;
    inst = instance_create(x, y, obj_gauntLW);
    with (inst)
        {
            image_angle = other.debrisangle;
        }
    inst = instance_create(x, y, obj_gauntRW);
    with (inst)
        {
            image_angle = other.debrisangle;
        }
    inst = instance_create(x, y, obj_gauntTorso);
    with (inst)
        {
            image_angle = other.debrisangle;
        }   
    inst = instance_create(x, y, obj_gauntTail);
    with (inst)
        {
            image_angle = other.debrisangle;
        }                           
    instance_destroy();
}

// if near an explosion reduce health to death
if instance_exists(obj_explosion128)
    {
        proximity = distance_to_object(obj_explosion128)
        if proximity &lt;= explosionproximity currenthealth -= 0.2
    }

    
//----------------------------------------
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_hugeblock">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// clean up if gaunt gets stuck in environment

instance_destroy();


</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
