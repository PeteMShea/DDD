<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_Shark128</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
/// initialise variables
ship = "shark";


if ship =="shark"
{
    thrust = 0.001 * global.RM;       //thrust applied per frame of mouse input
    min_thrust = 0.01 * global.RM;
    max_forwardthrust = 0.35;
    max_backthrust = 0.2 * global.RM;
    thrustcounter = 20; //minimum number of frames thrust is applied before deceleration starts
    thrustacc = 1.001;    //how thrust accelerates while input is held
    inertia = 5;     //percentage speed lost per frame
    deceleration = 10;
    decay = 0.10;        // how quickly deceleration when not thrusting decays
    min_speed = 0.4 * global.RM;    // minimum ie terminal velocity
    max_speed = 2 * global.RM;      //maximum speed achievable
    maxturnspeed = 1.5;       //rate at which ship turns- degrees per frame 1
    turnacceleration = 0.10;    //how much turnspeed accelerates over time    
    turndeceleration = 0.1;    //how much turnspeed decelerates over time
    bouncemult = 0.5;     //how much ship bounces off walls 1 = inverted velocity on impact
    damagemult = 15;     //how much collision damage does
    armour = 1.0;       // Ship armour reduces damage (1 weak, 0 invincible)
    minvisualdamage = 2;    //how much damage must be to cause visual change
    damagecooldown = 2;    //How many seconds player is invincible after taking damage
    thrustparticles = false;
    thrustcolour = make_colour_rgb(80, 80, 80);
    shipscale = 18 * global.RM;     //radius of collision circle for ship
    trails = true;
    trailspeed = 0.75;   //minimum speed before trails are drawn at high alpha- 0 is on all the time
    turret = false;
    turretturn = 1;   //number of times turret will turn 2 degrees in a frame- increases as turret upgraded for faster speed with continued precision
    retro = true;    
    shoot_rate = 12;     //number of frames between bullets when mouse button held
    minlandspeed = 0.4;
    
}

script_execute(scr_updateplayer);       //update attributes based upon purchases

// shared static consts
damagecost = 10;        //how much gold it costs to repair 1 point of damage
madnesstopspeed = 0.025      //how much madness to apply per frame whenever player is near top speed

//Declarations

moveinput = 0;      // 0 no input, 1 left mouse input, 2 joy input
fireinput = 0;      // 0 no input, 1 left mouse input, 2 joy input
mousemove = false;
firebutton = 0;
speed_x = 0;
speed_y = 0;
destx = x;
desty = y;

if global.startroom == false       //not the start room
    {
        thrustdir = 270;
        thrust_angle = 270;
        image_angle = 270;
        
        //Autopilot
        global.autopilot = 120;    // was 120
        auto_x = 0;
        auto_y = 0.25 * global.RM;   //downwards thrust...
        autothrust = 10;   
    }



image_speed = 0;
turn_angle = image_angle;
turnspeed = 0;
backthrust = false;

desired_turnspeed = 0;
turning = 0;    // 0- not turning, 1- turning left, 2- turning right
turntest = false;   //set whenever player clicks on either of the turning angles
max_thrust = max_forwardthrust;
backwards = false;
landingokay = false;
landing = 0;    // 0- not happening, 1- left leg down, right leg down, 3 - landed

hitcollide = 0;
shoot_counter = 0;

dead = false;
burst = false;
deathcounter = 0;
deathsequencetime = 180;       //how long death sequence lasts for
deathstart = false;
startfade = 150;    //number of frames until fade to black starts
showmenu = false;   //draw menu once
collisionoff = false;   // debug option to disable collision

// set up gamepad
if gamepad_is_connected(0) gamepad_set_axis_deadzone(0, 0.15);
joyx = 0;
joyy = 0;
joystickused = 0;


// Add turret if wanted
if turret == true
    {
        instance_create(x, y, obj_sharkturret);
        instance_create(x, y, obj_sharkturretmounting);
    }

// Add a red light glow
inst = instance_create(x, y, obj_redlightglow);
with(inst)
{
    decay = 0;
}

// Add retro boosters if wanted
//if retro == true instance_create(x, y, obj_sharkRetro);

// Add Spec highlight
//instance_create(x, y, obj_sharkSpec);

// Add dirt mask
instance_create(x, y, obj_sharkDirt);

// setup visual damage
instance_create(x, y, obj_shipdamage_CR);
instance_create(x, y, obj_shipdamage_MR);
instance_create(x, y, obj_shipdamage_BR);
instance_create(x, y, obj_shipdamage_CL);
instance_create(x, y, obj_shipdamage_ML);
instance_create(x, y, obj_shipdamage_BL);
instance_create(x, y, obj_shipdamage_CC);

//invert the controls if desired
invertedthrust = true;
invertedturn = false;

         



/////////////////////////////////////////////////////////////////////////////
// Lighting Setup
//This script goes on the 'create' event of objects that need Sprite Lamp's
//lighting effects.
//The uniform variable stuff shouldn't really change, but down the bottom are
//the bits where you set your desired values for stuff.


/********************************************************************************/
//A whole bunch of shader variables - the 'u_' prefix means 'uniform variable'.
//These are just hooks to communicate with the shader.

//Maps. Note that we don't have to do the diffuse map - that's included as the
//base texture (gm_BaseTexture) automatically.
u_NormalDepthMap = shader_get_sampler_index(SpriteLampShader, "sl_NormalDepthMap");
u_SpecGlossMap = shader_get_sampler_index(SpriteLampShader, "sl_SpecGlossMap");
u_AOMap = shader_get_sampler_index(SpriteLampShader, "sl_AOMap");
u_EmissiveMap = shader_get_sampler_index(SpriteLampShader, "sl_EmissiveMap");

//Sprite Lamp variables that are handled by scripts
u_LightPos = shader_get_uniform(SpriteLampShader, "sl_LightPos");
u_SpriteAngle = shader_get_uniform(SpriteLampShader, "sl_SpriteAngle");
u_TextureRes = shader_get_uniform(SpriteLampShader, "sl_TextureRes");
u_LightColour = shader_get_uniform(SpriteLampShader, "sl_LightColour");

//Sprite Lamp variables that are set by the user
u_CelLevel = shader_get_uniform(SpriteLampShader, "sl_CelLevel");
u_Shininess = shader_get_uniform(SpriteLampShader, "sl_Shininess");
u_WrapAroundLevel = shader_get_uniform(SpriteLampShader, "sl_WrapAroundLevel");
u_AOStrength = shader_get_uniform(SpriteLampShader, "sl_AOStrength");
u_EmissiveStrength = shader_get_uniform(SpriteLampShader, "sl_EmissiveStrength");
u_AmplifyDepth = shader_get_uniform(SpriteLampShader, "sl_AmplifyDepth");

u_UpperAmbientColour = shader_get_uniform(SpriteLampShader, "sl_UpperAmbientColour");
u_LowerAmbientColour = shader_get_uniform(SpriteLampShader, "sl_LowerAmbientColour");
/********************************************************************************/



/********************************************************************************/
//Set your different maps here! Note that your diffuse map isn't done this way - 
//diffuse comes from whatever image is assigned to the object in the usual fashion.
normalDepthTexture = sprite_get_texture(spr_shipSharkNormal, 0);
//specGlossMap = sprite_get_texture(spr_shipSharkNormal, 0);
specGlossMap = sprite_get_texture(spr_shipSharkSpecGloss, 0);
aoMap = sprite_get_texture(spr_shipShark, 0);
emissiveMap = sprite_get_texture(spr_shipShark, 0);
//(note - this example doesn't have an emissive map so I'm using the diffuse map as
//a dummy and turning the emissive strength variable to zero. Eventually I'll have
//a couple of versions of the shader, so if you're not using certain features you
//done have to screw around with this kind of thing)


//Set shader variables here. Note that they get sent every frame,
//so feel free to change these values in script during play.
celLevel = 0.0;     //0
shininess = 25.0;   //40
wrapAroundLevel = 0.0;
aoStrength = 0.4;       //0.4
emissiveStrength = 0.00;     //0
amplifyDepth = 1.5;     //1.5

//Set texture resolution - needed for self-shadows. Presumably there is some way
//to automate this process - if you know how, tell me!
textureWidth = 512;
textureHeight = 256;


//Ambient colour components.
upperAmbient_Red = 0.5;     //0.2
upperAmbient_Green = 0.5;
upperAmbient_Blue = 0.5;

lowerAmbient_Red = 0.25;     //0.05
lowerAmbient_Green = 0.25;
lowerAmbient_Blue = 0.25;


//The nearest lightsource.
lightSource = instance_nearest(x,y,oLightSource);

//add the light to follow player






    
    
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// may not need anything here

show_debug_message("Wait's up");



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//update the ship as required
if turret == true &amp;&amp; !instance_exists(obj_sharkturret) 
    {
        instance_create(x, y, obj_sharkturret);
        instance_create(x, y, obj_sharkturretmounting);
    }


if global.pause == false 
{

if dead == false
{


// Movement
if global.autopilot &lt;= 0
        {
         // joystick input   
            joyx = gamepad_axis_value(0, gp_axislh);
            joyy = gamepad_axis_value(0, gp_axislv);
            righttrigger = gamepad_button_value(0, gp_shoulderrb);
            lefttrigger = gamepad_button_value(0, gp_shoulderlb);
            firebutton = gamepad_button_value(0, gp_face1);
            
            //show_debug_message("X: " + string(joyx) + "Y:" + string(joyy));
            //show_debug_message("X: " + string(joyleftx) + " Y:" + string(joylefty));
        
                
        // mouse input calculate direction and apply accelerating thrust    
        if mouse_check_button(mb_left)
            {
                mousemove = true;
                moveinput = 1
            }
      
        if mousemove == false &amp;&amp; mouse_check_button(mb_right)
            {
                mousemove = true;
                fireinput = 1
            }

        if mouse_check_button(mb_left) == 0 &amp;&amp; mouse_check_button(mb_right) == 0 mousemove = false;
        if mouse_check_button(mb_right) == 0 fireinput = 0; 
        
        if mousemove == false
            {
                if joyx != 0 || joyy != 0 moveinput = 2    // left stick to turn
                if joyx == 0 &amp;&amp; joyy == 0 moveinput = 0;                
            }

//show_debug_message("RB: " + string(righttrigger) + ", LB:" + string(lefttrigger)+ ", Moveinput:" + string(moveinput)+ ", Fireinput:" + string(fireinput)+ ", Mousemove:" + string(mousemove));                



        
if moveinput == 0
{
    backthrust = false;     //disable backthrust VFX when button released
}                
        
if moveinput == 1 || fireinput == 1           //mouse input on left button or right button
    {
        angle_mouse = point_direction(x, y, mouse_x, mouse_y);
    }
    
if moveinput == 1 ||  fireinput == 1
{        
        angle_diff = abs(image_angle - angle_mouse);
      if fireinput == 0  
        {

        if angle_diff &gt;= 30 &amp;&amp; angle_diff &lt;= 150 || angle_diff &gt;=210 &amp;&amp; angle_diff &lt;= 330 turntest = true else turntest = false
        if angle_mouse &lt; image_angle &amp;&amp; turntest == true angle_diff +=180;      //if we have chosen either of the possible turning directions
        if angle_diff &gt; 360 angle_diff -= 360

        rotcolcheck = noone;
        if angle_diff &gt;= 30 &amp;&amp; angle_diff &lt;= 150 &amp;&amp; turnspeed &lt;= 0 &amp;&amp; landing != 3 &amp;&amp; turning == 0          // turning left unless landed
                    {
                        turn_angle = angle_mouse;
                        if invertedturn == false turning = 1 else turning = 2
                    }
        
                if angle_diff &gt;= 210 &amp;&amp; angle_diff &lt;= 330 &amp;&amp; turnspeed &lt;= 0 &amp;&amp; landing != 3 &amp;&amp; turning == 0     // turning right unless landed
                    {
                        turn_angle = angle_mouse;
                        if invertedturn == false turning = 2 else turning = 1
                    }             
           } 
            // Turning the ship using fire input to aim nose
            if fireinput == 1 &amp;&amp; turret == false &amp;&amp; angle_diff &gt; 1           // turn towards aim point if holding fire and not fitted with turret
                {
                    turn_angle = angle_mouse;
                    fireanglediff = angle_difference(image_angle, turn_angle);
                    if fireanglediff &gt; 0 turning = 2 else turning = 1                    
                    //show_debug_message("image:" + string(image_angle) + " , mouse:" + string(angle_mouse));
                }
            if fireinput == 1 &amp;&amp; turret == false &amp;&amp; angle_diff &lt;= 1     //stop turning ship when firing with no turret when pointing at aim
                {
                    turning = 0;
                    turnspeed = 0;
                }            
                    
                        
                if turning == 1    
                    {
                        rotcolcheck = collision_line(x + lengthdir_x(33, image_angle + 135), y + lengthdir_y(33 * global.RM, image_angle + 135), x + lengthdir_x(24 * global.RM, image_angle + 105), y + lengthdir_y(24 * global.RM, image_angle + 105), obj_block, false, true);
                        //if rotcolcheck != noone show_debug_message(string(rotcolcheck));
                        if rotcolcheck == noone
                            {                       
                                turnspeed += turnacceleration;
                                turn_angle += 2
                                if turn_angle &gt;360 turn_angle -= 360;                        
                            }
                        else turnspeed = 0;
        
                    }
        
                    
                if turning == 2    
                    {                                    
                        rotcolcheck = collision_line(x + lengthdir_x(33 * global.RM, image_angle + 225), y + lengthdir_y(33 * global.RM, image_angle + 225), x + lengthdir_x(24 * global.RM, image_angle + 255), y + lengthdir_y(24 * global.RM, image_angle + 255), obj_block, false, true);
                        //if rotcolcheck != noone show_debug_message(string(rotcolcheck));
                        if rotcolcheck == noone
                            {
                                turnspeed += turnacceleration
                                turn_angle -= 2
                                if turn_angle &lt;0 turn_angle += 360;
                            }
                        else turnspeed = 0;
                    }
        //if turning &gt; 0 show_debug_message("image angle: " + string(image_angle) + " , angle_mouse: " + string(angle_mouse) + " , angle diff: " + string(angle_diff)); 

        if moveinput == 1 &amp;&amp; fireinput == 0
        {             
            if angle_diff &gt; 330 || angle_diff &lt; 30 &amp;&amp; turning == 0          //forwards thrust
            {
                turn_angle = image_angle;
                if invertedthrust == false
                    {
                        turn_angle = image_angle;
                        script_execute(scr_forwardthrust, turn_angle);
                        backwards = false;
                    }
                else
                    {
                        turn_angle = image_angle;
                        script_execute(scr_backthrust);
                        backwards = true;                    
                    }
                landing = 0;
            }
   
         if angle_diff &gt; 150 &amp;&amp; angle_diff &lt; 210 &amp;&amp; landing != 3 &amp;&amp; turning == 0         //backwards thrust- do not allow if landed
            {
                turn_angle = image_angle;
                if invertedthrust == false
                    {                        
                        script_execute(scr_backthrust);
                        backwards = true;
                    }
                else
                    {
                        script_execute(scr_forwardthrust, turn_angle);
                        backwards = false;
                    }                         
            }                       
        }
    }
else if moveinput == 2
    {
        jx = joyx
        jy = joyy
        angle_joy = point_direction(0, 0, jx, jy);        
        angle_diff = angle_difference(angle_joy, image_angle);
        show_debug_message("X: " + string(joyx) + ", Y:" + string(joyy) + ", Angle:" + string(angle_joy) + ", Angle:" + string(angle_diff));
        if angle_diff != 0 turntest = true else turntest = false;
        rotcolcheck = noone;
        if angle_diff &gt;= 2 &amp;&amp; turnspeed &lt;= 0 &amp;&amp; landing != 3 &amp;&amp; turning == 0          // turning left unless landed
                    {
                        turning = 1;  
                        turn_angle = angle_joy;
                        rotcolcheck = collision_line(x + lengthdir_x(33, image_angle + 135), y + lengthdir_y(33 * global.RM, image_angle + 135), x + lengthdir_x(24 * global.RM, image_angle + 105), y + lengthdir_y(24 * global.RM, image_angle + 105), obj_block, false, true);
                        //if rotcolcheck != noone show_debug_message(string(rotcolcheck));
                        if rotcolcheck == noone
                            {                       
                                turnspeed += turnacceleration;
                                turn_angle += 2
                                if turn_angle &gt;360 turn_angle -= 360;
                      
                            }
                        else turnspeed = 0;
                    }
        
        if angle_diff &lt;= -2 &amp;&amp; turnspeed &lt;= 0 &amp;&amp; landing != 3 &amp;&amp; turning == 0     // turning right unless landed
                    {
                        turning = 2;
                        turn_angle = angle_joy;
                        rotcolcheck = collision_line(x + lengthdir_x(33 * global.RM, image_angle + 225), y + lengthdir_y(33 * global.RM, image_angle + 225), x + lengthdir_x(24 * global.RM, image_angle + 255), y + lengthdir_y(24 * global.RM, image_angle + 255), obj_block, false, true);
                        //if rotcolcheck != noone show_debug_message(string(rotcolcheck));
                        if rotcolcheck == noone
                            {
                                turnspeed += turnacceleration
                                turn_angle -= 2
                                if turn_angle &lt;0 turn_angle += 360;

                            }
                        else turnspeed = 0;
                    }           
      if angle_diff &lt; 2 &amp;&amp; angle_diff &gt; -2
      {
        turning = 0;
        turnspeed = 0;
      }  
        
    }   

} 
if moveinput == 0 &amp;&amp; fireinput == 0
        {
            turning = 0;
            turnspeed = 0;
            //turn_angle = image_angle;
        }
            
if global.autopilot &lt;= 0
    {     
    if righttrigger &gt; 0 
        {             
            if turning == 0          //forwards thrust
            {
                turn_angle = image_angle;
                if invertedthrust == true
                    {
                        turn_angle = image_angle;
                        script_execute(scr_forwardthrust, turn_angle);
                        backwards = false;
                    }
                else
                    {
                        turn_angle = image_angle;
                        script_execute(scr_backthrust);
                        backwards = true;                    
                    }
                landing = 0;
            }
        }
    if lefttrigger &gt; 0  &amp;&amp; global.autopilot &lt;= 0
        {
         if landing != 3 &amp;&amp; turning == 0         //backwards thrust- do not allow if landed
            {
                turn_angle = image_angle;
                if invertedthrust == true
                    {                        
                        script_execute(scr_backthrust);
                        backwards = true;
                    }
                else
                    {
                        script_execute(scr_forwardthrust, turn_angle);
                        backwards = false;
                    }                         
            }                       
        }        
    }           
          
// Autopilot control
if global.autopilot &gt; 0 &amp;&amp; global.autopilot &lt; 999
{
        global.autopilot -= 1;
        
        thrustcounter = autothrust; //minimum number of frames thrust is applied before deceleration starts
                        
        // Calculate normalised vectors for moving player to dest
        speed_x = auto_x;
        speed_y = auto_y;
                        
             
        //show_debug_message ("destx: " + string(destx) + ", auto_x: " + string(auto_x) + "desty: " + string(desty) + ", auto_y: " + string(auto_y));   
                        
                        
        joystickused = 0;
                      
        if thrustparticles == true effect_create_below(ef_spark, x + lengthdir_x(16 * global.RM, thrustdir), y + lengthdir_y(16 * global.RM, thrustdir), 0.1, thrustcolour);
        if trails == true &amp;&amp; backwards == false
            {
                inst = instance_create(x , y , obj_sharkthrust);
                with (inst)
                {
                    image_angle = other.image_angle;
                }
            } 
        if backwards == true
            {
                script_execute(scr_backthrust);
            }
}

    
// thrust control
if thrustcounter &gt;= 0 &amp;&amp; global.autopilot &lt;=0
    {
        
        // reset deceleration to base value 
        deceleration = inertia; 
        
        vx = (destx - x);
        vy = (desty - y);
    
        len = sqrt(vx * vx + vy * vy);
    
        vx = vx / len;
        vy = vy / len;
        
        
        // Multiply normalised vector by ship thrust
    if joyx != 0 || joyy != 0
        {
            thrust_x = -joyx * thrust;
            thrust_y = -joyy * thrust;
        }
    
    else
        {        
            thrust_x = vx * thrust;
            thrust_y = vy * thrust;
        }       
         
        // Add thrust from player input to player's current speed 
        speed_x += thrust_x;
        speed_y += thrust_y;
        
        speed_x = clamp(speed_x, -max_speed, max_speed);
        speed_y = clamp(speed_y, -max_speed, max_speed);
        
        if speed_x &gt;= max_speed * 0.8 || speed_y &gt;= max_speed * 0.8 global.madness += madnesstopspeed;      //fast speeds make you mad
        
        thrustcounter -= 1;
        
        thrustdir = point_direction(x, y, x - thrust_x, y - thrust_y); 
        
        if backwards == false image_index = 1; 

    }

    
        
    // when minimum number of thrust time has passed begin decelerating  
    if thrustcounter &lt;= 0
    {

                //reset thrust
            thrust = min_thrust;
        
        // reduce speed by deceleration amount each frame
        speed_x -= (speed_x * deceleration/1000);
        speed_y -= (speed_y * deceleration/1000);
        
        //reduce deceleration by decay amount each frame (clamped to 0)
        deceleration -= decay;
        deceleration = clamp(deceleration, 0, inertia);
        
        image_index = 0; 
     
    } 
   

//  collision detection
if collisionoff == false &amp;&amp; global.autopilot &lt;= 0            //debug option for disabling collision
{
    colcheck = noone;
    
    colcheck = collision_circle(x + speed_x, y + speed_y, shipscale, obj_block, false, true) 
    if colcheck == noone colcheck = collision_circle(x + lengthdir_x(32 * global.RM, image_angle + 140), y + lengthdir_y(32 * global.RM, image_angle + 140), 8, obj_block, false, true)
    if colcheck == noone colcheck = collision_circle(x + lengthdir_x(32 * global.RM, image_angle + 230), y + lengthdir_y(32 * global.RM, image_angle + 230), 8, obj_block, false, true)  
    if colcheck == noone colcheck = collision_circle(x + lengthdir_x(-3 * global.RM, thrustdir) + speed_x, y + speed_y, shipscale, obj_asteroid, true, true)
    
    if colcheck != noone
    
    {
    
        if collision_circle(x+ speed_x, y + speed_y, shipscale + 3 * global.RM, obj_asteroid, true, true)
    
            {
            var inst;
            //instance_create(x - speed_x + lengthdir_x(32, thrustdir), y - speed_y + lengthdir_y(32, thrustdir), obj_debug);
        
                
            inst = instance_nearest(x + speed_x, y + speed_y, obj_asteroid);
            if inst != noone
                {
                    ax = (inst).x;
                    ay = (inst).y;
                    avector = point_direction(ax, ay, x, y);
                    loc_x = ax + lengthdir_x(16 * global.RM, avector);
                    loc_y = ay + lengthdir_y(16 * global.RM, avector);
                    extended_x = x + lengthdir_x(32 * global.RM, thrustdir);
                    extended_y = y + lengthdir_y(32 * global.RM, thrustdir); 
                    with(inst)
                    {    
                        //show_debug_message(string(inst));
                        hit_x = other.x;
                        hit_y = other.y;
                        ext_x = other.extended_x;
                        ext_y = other.extended_y;
                        hitspeed_x = other.speed_x;
                        hitspeed_y = other.speed_y;
                        asteroidhit = 1;        // 1 = hit by player
                    }
                }
            }
        else
        // if hit something other than asteroid- calculate collision point loc_x, loc_y based upon thrustdir
            {
                l_angle = point_direction(x, y, x + speed_x, y + speed_y);
                loc_x = x + lengthdir_x(shipscale, l_angle);
                loc_y = y + lengthdir_y(shipscale, l_angle);
            
            }
    
        //now check for leg collisions for landing
        leftlegcheck = collision_circle(x + lengthdir_x(32 * global.RM, image_angle + 140), y + lengthdir_y(32 * global.RM, image_angle + 140), 8, obj_block, false, true)
        rightlegcheck = collision_circle(x + lengthdir_x(32 * global.RM, image_angle + 230), y + lengthdir_y(32 * global.RM, image_angle + 230), 8, obj_block, false, true)
        currrentspeed = sqrt(speed_x * speed_x + speed_y * speed_y);          
        if currrentspeed &lt;= minlandspeed landingokay = true else landingokay = false
        if global.autopilot &gt; 0 landingokay = false
        if leftlegcheck == noone &amp;&amp; rightlegcheck == noone landing = 0      //not landing as no legs in contact with ground       
        if leftlegcheck != noone &amp;&amp; rightlegcheck != noone &amp;&amp; landingokay == true       //both legs down at same time
            {
                script_execute(scr_landingsequence, landing);
            } 
            
        if leftlegcheck != noone &amp;&amp; rightlegcheck == noone &amp;&amp; landingokay == true &amp;&amp; landing == 0      //left leg hit
            {
                //show_debug_message("left leg down");
                speed_x = 0;
                speed_y = 0;
                landing = 1;    //in progress
                
                //now check if the right leg is within a reasonable range of the ground before landing sequence
                landx = x + lengthdir_x(40 * global.RM, image_angle + 215); 
                landy = y + lengthdir_y(40 * global.RM, image_angle + 215);        
                //instance_create(landx, landy, obj_debug);
                
                var legcheck = collision_point(landx, landy, obj_block, false, false);            
                if legcheck != noone script_execute(scr_landingsequence, landing) else landing = 0;                         
                            
            }        
    
        if leftlegcheck == noone &amp;&amp; rightlegcheck != noone  &amp;&amp; landingokay == true &amp;&amp; landing == 0     //right leg hit so turn to the left
            {
                //show_debug_message("right leg down");            
                speed_x = 0;
                speed_y = 0;            
                landing = 2;    // in progress
                
                //now check if the left leg is within a reasonable range of the ground before landing sequence
                landx = x + lengthdir_x(40 * global.RM, image_angle + 145); 
                landy = y + lengthdir_y(40 * global.RM, image_angle + 145);            
                //instance_create(landx, landy, obj_debug);   
                
                var legcheck = collision_point(landx, landy, obj_block, false, false);            
                if legcheck != noone script_execute(scr_landingsequence, landing) else landing = 0;  
                           
            }
    
                                   
     
        // show_debug_message(string(speed_x) + " , " + string(speed_y));
    
        // calculate new resolve vector pointing away from the object just hit
        objhit_x = colcheck.x     
        objhit_y = colcheck.y
        //obj_vec = point_direction(objhit_x, objhit_y, x, y);
        
        //now turn this vector into a new direction of travel      
    
        ox = (x - objhit_x);
        oy = (y - objhit_y);
        
        len = sqrt(ox * ox + oy * oy);
        
        ox = ox / len;
        oy = oy / len;
        
        //now bounce away unless landing or trying to
        if landing == 0
        {
            min_bounce_x = sign(ox) * 0.1;
            min_bounce_y = sign(oy) * 0.1;     
            bounce_x = abs(speed_x) * ox * bouncemult + min_bounce_x;
            bounce_y = abs(speed_y) * oy * bouncemult + min_bounce_y;
            
            speed_x = + bounce_x;
            speed_y = + bounce_y;
        }
        //show_debug_message("bounce: " + string(speed_x) + " , " + string(speed_y));
     
        //trigger damage unless in cooldown time   
        if hitcollide &lt;= 0
            {    
                hitcollide = damagecooldown * 60;  
            }
        
            
                 
    } 
    
    // Player has collided with bad thing
    if hitcollide &gt;= (damagecooldown * 60)
        {
            damagespeed = sqrt(speed_x * speed_x + speed_y * speed_y);
            damage = (damagespeed * damagemult * armour)
            global.playerHealth -= damage;
            global.madness += damage;
            
            script_execute(scr_shipvisualdamage, x, y, loc_x, loc_y, damage);
            
              hitcollide -= 1;
            global.playerdamaged = 20;
         }
    else
        {
            hitcollide -= 1;
    
        }     
}  
  
// Apply movement to player
    x += speed_x;
    y += speed_y;
    
    if turret == true
    {
        obj_sharkturret.x = x + lengthdir_x(18, image_angle);
        obj_sharkturret.y = y + lengthdir_y(18, image_angle);
        obj_sharkturretmounting.x = x + lengthdir_x(18, image_angle);
        obj_sharkturretmounting.y = y + lengthdir_y(18, image_angle);
        obj_sharkturretmounting.image_angle = image_angle;               
    }
    
    if global.autopilot &lt;= 0 &amp;&amp; y &lt;=80 y =80

// rotation
if turnspeed &gt; 0
    {
        desired_turnspeed = desired_turnspeed + turnspeed
        if desired_turnspeed &gt; maxturnspeed desired_turnspeed = maxturnspeed 
    }
else
    {
        if desired_turnspeed &gt; 0 desired_turnspeed -= turndeceleration
    }   

if desired_turnspeed &gt; 0

    {     
        if turning == 1
        {
            inst = instance_create(x, y, obj_sharkRThrust);
            with (inst)
                {
                    image_angle = other.image_angle
                }         
            rotcolcheck = collision_line(x + lengthdir_x(33 * global.RM, image_angle + 225), y + lengthdir_y(33 * global.RM, image_angle + 225), x + lengthdir_x(24 * global.RM, image_angle + 255), y + lengthdir_y(24 * global.RM, image_angle + 255), obj_block, false, true);
            if rotcolcheck == noone        
                {
                    image_angle += desired_turnspeed;
                }
        }
        if turning == 2
        {
            inst = instance_create(x, y, obj_sharkLThrust);
            with (inst)
                {
                    image_angle = other.image_angle
                }
            rotcolcheck = collision_line(x + lengthdir_x(33 * global.RM, image_angle + 135), y + lengthdir_y(33 * global.RM, image_angle + 135), x + lengthdir_x(24 * global.RM, image_angle + 105), y + lengthdir_y(24 * global.RM, image_angle + 105), obj_block, false, true);
            if rotcolcheck == noone                        
                {
                    image_angle -= desired_turnspeed;
                }
        }
    if image_angle &gt;= 360 image_angle -=360
    if image_angle &lt; 0 image_angle +=360             
    }
    

        
// Firing
if fireinput == 1 || firebutton &gt; 0

{
    if turret == true
        {
            bulletaimx = x - lengthdir_x(100 * global.RM, obj_sharkturret.image_angle);
            bulletaimy = y - lengthdir_y(100 * global.RM, obj_sharkturret.image_angle);
        }
    else
        {
            bulletaimx = x - lengthdir_x(100 * global.RM, image_angle);
            bulletaimy = y - lengthdir_y(100 * global.RM, image_angle);
        }
    script_execute(scr_playerShoot, bulletaimx, bulletaimy, shoot_counter);   
}    


// add red trails

if trails == true
{
    inst = instance_create(x , y , obj_redtrail);
    testtrails = abs(speed_x) + abs(speed_y) + abs(desired_turnspeed)  
    with (inst)
        {
            image_angle = other.image_angle;
            image_alpha = other.testtrails * 0.2;
            decay = other.testtrails * 0.002;
        }            
}    
   
    
    
// Apply animation to ship if in damage state

if global.playerdamaged &gt;0 
    {
            //image_index = 1; 
            global.playerdamaged -= 1;
         
    }
else
    {
            //image_index = 0; 
    }


        
    
    

// check if player has reached exit

if collision_circle(x+ speed_x, y + speed_y, shipscale + 3 * global.RM, obj_exittrigger, false, true)
    {    
        vx = view_xport[0];
        vy = view_yport[0];
        instance_create( vx, vy, eff_fadetoblack );
        if global.loading == true script_execute(scr_gotonewlevel);    
    
    }
// Death

if global.playerHealth &lt;= 0 &amp;&amp; dead == false
    {
        dead = true;
        sprite_index = spr_shipSharkDead;
        image_speed = 0.1;
        debrisdir[0] = 140;
        debrisdir[1] = 90;        
        debrisdir[2] = 70;        
        debrisdir[3] = 10;        
        debrisdir[4] = 330;
        debrisdir[5] = 260;        
        debrisdir[6] = 210;
        px = x;
        py = y;
  
        show_debug_message("Deid");                    
    }

}

if dead == true &amp;&amp; deathcounter == 0
    {
        show_debug_message("Burstbaw");    
        deathcounter += 1;   
    
    }
if dead == true &amp;&amp; deathcounter &lt; deathsequencetime
{
        if image_index &gt;= 3 &amp;&amp; burst == false
            {
                burst = true;
                image_speed = 0
                debrisangle = image_angle;
                for(index = 0; index &lt; 7; index += 1)
                    {
                        point = debrisdir[index];
                        inst = instance_create(x, y, obj_sharkDebris)
                        with(inst)
                            {
                                image_angle = other.debrisangle;
                                image_index = other.index;
                                direction = other.debrisangle + other.point;                                               
                            }
                    }
                image_index = 4;       //blank sprite- swap ship with new instanced debris objects
                         
            }
        if image_index &gt;= 1
            {
                
                script_execute(scr_deathsequence, px, py, startfade, showmenu);        
            }           
}



// end of pause condition
}




//show_debug_message ("thrustdir: " + string(thrustdir));


    
 //    show_debug_message("Speed: " + string(speed_x) + " , " + string(speed_y) + "Thrust:" + string(thrust) + "Deceleration:" + string(deceleration))
 
 
 










</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="81">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// debug test object under mouse

testx = mouse_x;
testy = mouse_y;

debug = instance_place(testx, testy, obj_newblock);

show_debug_message(string(debug));



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="70">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.pause = true; 

vx = view_xport[0];
vy = view_yport[0];
instance_create( vx, vy, eff_fadetoblack );
        
        
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="67">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// debug key for disabling player collision

if collisionoff == false collisionoff = true else collisionoff = false;


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="49">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

show_debug_message("image angle: " + string(image_angle) + " , angle diff: " + string(angle_diff));

show_debug_message("turning: " + string(turning));

//instance_create(x ,y, obj_debug);
//instance_create(x + lengthdir_x(33, image_angle + 135), y + lengthdir_y(33, image_angle + 135), obj_debug);
//instance_create(x + lengthdir_x(24, image_angle + 105), y + lengthdir_y(24, image_angle + 105), obj_debug);

//instance_create(x + lengthdir_x(33, image_angle + 225), y + lengthdir_y(33, image_angle + 225), obj_debug);
//instance_create(x + lengthdir_x(24, image_angle + 255), y + lengthdir_y(24, image_angle + 255), obj_debug);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="5" enumb="36">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//temp test for inventory

if !instance_exists(obj_PauseLanded) instance_create(x,y, obj_PauseLanded);


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

shader_set(SpriteLampShader);

shader_set_uniform_f(u_SpriteAngle, image_angle * pi / 180.0);
shader_set_uniform_f(u_TextureRes, textureWidth, textureHeight);
shader_set_uniform_f(u_LightPos,
        lightSource.cameraSpacePosX, lightSource.cameraSpacePosY,
        lightSource.zPosition);
shader_set_uniform_f(u_LightColour,
        lightSource.colourRed, lightSource.colourGreen, lightSource.colourBlue);
         
         
texture_set_stage(u_NormalDepthMap, normalDepthTexture);
texture_set_stage(u_SpecGlossMap, specGlossMap);
texture_set_stage(u_AOMap, aoMap);
texture_set_stage(u_EmissiveMap, emissiveMap);

shader_set_uniform_f(u_CelLevel, celLevel);
shader_set_uniform_f(u_Shininess, shininess);
shader_set_uniform_f(u_WrapAroundLevel, wrapAroundLevel);
shader_set_uniform_f(u_AOStrength, aoStrength);
shader_set_uniform_f(u_EmissiveStrength, emissiveStrength);
shader_set_uniform_f(u_AmplifyDepth, amplifyDepth);

shader_set_uniform_f(u_UpperAmbientColour, 
        upperAmbient_Red, upperAmbient_Green, upperAmbient_Blue);
shader_set_uniform_f(u_LowerAmbientColour,
        lowerAmbient_Red, lowerAmbient_Green, lowerAmbient_Blue);


draw_self();

shader_reset();

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
